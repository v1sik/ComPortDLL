unit ComPortLib;

interface

uses
  Winapi.Windows, Vcl.Forms, CPort, System.SysUtils, Vcl.Dialogs;

procedure ShowComPortSettings(ParentHandle: HWND); stdcall;
function OpenComPort: Boolean;
procedure CloseComPort();
procedure SetDataMessage(const Msg: string); stdcall;
procedure SetComPort(strComPort: PAnsiChar; strBaudRate: Integer; strParityBits: Integer );  stdcall;
function GetDataMessage(Buffer: PByte; BufferSize: Integer): Integer; stdcall;
function IntToBaudRateEnum(const S: Integer): TBaudRate;
function BaudRateEnumToInt(BR: TBaudRate): Integer;
function RadioIndexToParity(Index: Integer): TParityBits;
function ParityToRadioIndex(P: TParityBits): Integer;
implementation

uses
  PortSettingsForm; // ‘орма, которую мы показываем

  var cpComPort: TComPort;

function BaudRateEnumToInt(BR: TBaudRate): Integer;
begin
  case BR of
    br110: Result := 110;
    br300: Result := 300;
    br600: Result := 600;
    br1200: Result := 1200;
    br2400: Result := 2400;
    br4800: Result := 4800;
    br9600: Result := 9600;
    br14400: Result := 14400;
    br19200: Result := 19200;
    br38400: Result := 38400;
    br56000: Result := 56000;
    br57600: Result := 57600;
    br115200: Result := 115200;
    br128000: Result := 128000;
    br256000: Result := 256000;
  else
    Result := 9600;
  end;
end;

function IntToBaudRateEnum(const S: Integer): TBaudRate;
begin
  if S = 110 then Result := br110
  else if S = 300 then Result := br300
  else if S = 600 then Result := br600
  else if S = 1200 then Result := br1200
  else if S = 2400 then Result := br2400
  else if S = 4800 then Result := br4800
  else if S = 9600 then Result := br9600
  else if S = 14400 then Result := br14400
  else if S = 19200 then Result := br19200
  else if S = 38400 then Result := br38400
  else if S = 56000 then Result := br56000
  else if S = 57600 then Result := br57600
  else if S = 115200 then Result := br115200
  else if S = 128000 then Result := br128000
  else if S = 256000 then Result := br256000
  else Result := br9600;
end;

function RadioIndexToParity(Index: Integer): TParityBits;
begin
  case Index of
    1: Result := prOdd;
    2: Result := prEven;
  else
    Result := prNone;
  end;
end;

function ParityToRadioIndex(P: TParityBits): Integer;
begin
  case P of
    prOdd: Result := 1;
    prEven: Result := 2;
  else
    Result := 0;
  end;
end;

procedure InitComPort; stdcall;
begin
  if not Assigned(cpComPort) then
  begin
    cpComPort := TComPort.Create(nil);
    cpComPort.Port := 'COM1';
    cpComPort.BaudRate := br9600;
    // другие начальные значени€
  end;
end;

function OpenComPort: Boolean;
begin
  Result := False;
  if not Assigned(cpComPort) then
    Exit;
  try
    if not cpComPort.Connected then
      cpComPort.Open;
    Result := True;
  except
    on E: Exception do
    begin
      ShowMessage('Ќе удалось открыть COM-порт: ' + E.Message);
      Result := False;
    end;
  end;
end;

procedure CloseComPort();
begin
  if not Assigned(cpComPort) then
    Exit;
  try
    if cpComPort.Connected then
      cpComPort.Close;
  except
    on E: Exception do
    begin
      ShowMessage('ќшибка при закрытии COM-порта: ' + E.Message);
      raise;
    end;
  end;
end;

procedure SetNumComPort(ComPort: TComPort; const PortName: string);
begin
  if Assigned(ComPort) then
    ComPort.Port := PortName;
end;

procedure SetBaudComPort(Baud: TBaudRate);
begin
  if Assigned(cpComPort) then
    cpComPort.BaudRate := Baud;
end;

procedure SetDataMessage(const Msg: string); stdcall;
begin
  if Assigned(cpComPort) and cpComPort.Connected then
  begin
    try
      cpComPort.WriteStr(Msg);
    except
      on E: Exception do
        ; // можно логировать: E.Message
    end;
  end;
end;
function GetDataMessage(Buffer: PByte; BufferSize: Integer): Integer; stdcall;
var
  Temp: string;
  BytesToRead: Integer;
begin
  Result := 0;

  if Assigned(cpComPort) and cpComPort.Connected then
  begin
    BytesToRead := cpComPort.InputCount;
    if BytesToRead > 0 then
    begin
      if BytesToRead > BufferSize then
        BytesToRead := BufferSize; // чтобы не выйти за пределы

      SetLength(Temp, BytesToRead);
      cpComPort.ReadStr(Temp, BytesToRead);

      //  опируем данные в буфер
      Move(PAnsiChar(AnsiString(Temp))^, Buffer^, BytesToRead);
      Result := BytesToRead; // возвращаем количество байт
    end;
  end;
end;

procedure ShowComPortSettings(ParentHandle: HWND); stdcall;
begin
  if not Assigned(cpComPort) then
    InitComPort; // создаст один раз

  Application.Handle := ParentHandle;

  with TFormComSettings.Create(nil) do
  try
    InitMenu(cpComPort); // <-- вот сюда передаЄшь
    ShowModal; // внутри при изменении порта применитс€ к cpComPort
  finally
    Free;
  end;
end;

procedure SetComPort(strComPort: PAnsiChar; strBaudRate: Integer; strParityBits: Integer );  stdcall;
var
  PortStr: string;
begin
  if Assigned(strComPort) then
    PortStr := string(strComPort)
  else
    PortStr := '';
    cpComPort.Port := PortStr; // сразу примен€ем
    cpComPort.BaudRate:= IntToBaudRateEnum(strBaudRate);
    cpComPort.Parity.Bits := RadioIndexToParity(strParityBits);
end;

function GetComPortConfigStr(Buffer: PAnsiChar; BufferSize: Integer): Integer; stdcall;
var
  ConfigStr: AnsiString;
  ParityStr: Integer;
begin
  Result := 0;
  if (not Assigned(cpComPort)) or (Buffer = nil) or (BufferSize <= 0) then
    Exit;

  case cpComPort.Parity.Bits of
    prNone: ParityStr := 0;
    prOdd: ParityStr := 1;
    prEven: ParityStr := 2;
  end;

  ConfigStr := Format('%s, %d, %d',
    [cpComPort.Port, BaudRateEnumToInt(cpComPort.BaudRate), ParityStr]);

  if Length(ConfigStr) >= BufferSize then
    SetLength(ConfigStr, BufferSize - 1); // оставл€ем место дл€ нул€

  Move(PAnsiChar(ConfigStr)^, Buffer^, Length(ConfigStr));
  Buffer[Length(ConfigStr)] := #0;
  Result := Length(ConfigStr);
end;


initialization
  InitComPort;
end.

